package com.test.largefile;

import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class LargeFileTest {

	public static String getUserRank(String userId, String filePath) {
		long starTime = System.currentTimeMillis();

		String score = "";
		FileChannel fc = null;
		RandomAccessFile raf = null;
		
		//临时区块map
		Map<Integer, MappedByteBuffer> tempMbbMap = new HashMap<>();
		
		try {
			raf = new RandomAccessFile(filePath, "r");
			fc = raf.getChannel();
			// 分成100块
			long tempBlockSize = fc.size() / 100;
			// 开始结束坐标
			long endIndex = 0;
			//开始坐标
			long beginIndex = 0;
			//计算出每个区块的MappedByteBuffer
			for (int i = 0; i < 100; i++) {
				beginIndex = endIndex;
				//计算结束坐标
				endIndex += tempBlockSize;
				// 计算出完整的结束位置
				getCompleteEndIndex(endIndex, raf, '\n');
				//装进临时区块map
				tempMbbMap.put(i, fc.map(FileChannel.MapMode.READ_ONLY, beginIndex,endIndex-beginIndex));
			}
			
			ExecutorService beforeService = Executors.newFixedThreadPool(3);
	        CountDownLatch latch = new CountDownLatch(100);
			for (int i = 0; i < 100; i++) {
				
			}
		} catch (Exception e) {
			e.printStackTrace();
		} finally {
			try {
				raf.close();
				fc.close();
			} catch (Exception e2) {
				e2.printStackTrace();
			}
		}
		long endTime = System.currentTimeMillis();
		System.out.println("耗时：" + (endTime - starTime));
		System.out.println("用户：" + userId + ",分数：" + score);
		return score;
	}
	
	/**
	 * 寻找用户分数线程
	 * @author Administrator
	 */
	static class findScoreThread implements Runnable {
		
		private CountDownLatch latch;
		private MappedByteBuffer tempMbbMap;
		private String userId;
		
		public findScoreThread(String userId,MappedByteBuffer tempMbbMap, CountDownLatch latch){
			super();
			this.userId = userId;
			this.tempMbbMap = tempMbbMap;
			this.latch = latch;
			
		}

		@Override
		public void run() {
			
			boolean findFlag = false;
			byte[][] lineByte = null;
			while ((lineByte = readLine(tempMbbMap)) != null) {
				if (Arrays.equals(userId.getBytes(), lineByte[0])) {
					findFlag = true;
					break;
				}
			}
			
			//找到分数终止所有线程
			if (findFlag) {
				for (int j = 0; j < latch.getCount(); j++) {
					latch.countDown();
				}
				
				try {
					System.out.println("用户：" + userId + ",分数：" + new String(lineByte[1], "GBK"));
				} catch (UnsupportedEncodingException e) {
					e.printStackTrace();
				}
			}else{
				latch.countDown();
			}
			
		}
		
	}

	/**
	 * 计算完整结束位置
	 * @param endIndex
	 * @param raf
	 * @param separator
	 */
	public static void getCompleteEndIndex(long endIndex,RandomAccessFile raf, char separator) {
		try {
			raf.seek(endIndex);
			// 遇到分隔符结束
			while (raf.read() != separator) {
				endIndex++;
			}
			endIndex++;
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * 读取每一行的内容
	 * 
	 * @param mbb
	 * @param begin
	 * @param length
	 * @return
	 */
	public static byte[][] readLine(MappedByteBuffer mbb) {
		// 当前缓冲区总长度
		int limit = mbb.limit();
		// 当前位置
		int position = mbb.position();
		// 读取完直接跳出
		if (position >= limit) {
			return null;
		}
		// 用户ID
		ByteBuffer bb = ByteBuffer.allocate(36);
		// 用户分数
		ByteBuffer cc = ByteBuffer.allocate(7);
		// 读取到逗号标识
		boolean f = false;
		try {
			while (position < limit) {
				byte b = mbb.get();
				// 每行当读取到逗号时将后面的部分装进用户分数byte数组
				if (b == 44) {
					f = true;
				}
				// 碰到换行符结束读取
				if (System.getProperty("line.separator").equals("\r\n") && (b == 13 || b == 10)) {
					mbb.get();
					break;
				} else if (f) {
					cc.put(b);
				} else {
					bb.put(b);
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
		return new byte[][] { bb.array(), cc.array() };
	}

	public static void main(String[] args) {
		// 源文件路径
		String inputFilePath = "E:/JavaTestFile/user_score.csv";
		// 取用户名次
		getUserRank("1661205e-14de-4805-b493-25a7cd177026", inputFilePath);

	}
}
