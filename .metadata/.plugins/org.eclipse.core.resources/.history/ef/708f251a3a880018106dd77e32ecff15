package com.test.largefile;

import java.io.File;
import java.io.FileInputStream;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Arrays;

public class LargeFileTest {
	
	public static String getUserRank(String userId,String filePath){
		long starTime=System.currentTimeMillis();
		
		String score = "";
		FileInputStream fis = null;
		FileChannel fc = null;
		MappedByteBuffer mbb = null;
		RandomAccessFile randomAccessFile = null;
		try {
			fis = new FileInputStream(new File(filePath));
			fc = fis.getChannel();
			
			//分成100块
			long tempBlockSize = fc.size() / 100;
			//开始结束坐标
			long checkIndex = 0;
			//开始位置数组
			long[] beginIndexs = new long[100];
			//结束位置数组
			long[] endIndexs = new long[100];
			
			randomAccessFile = new RandomAccessFile(filePath, "r");
			for (int n = 0; n < 100; n++) {
				beginIndexs[n] = checkIndex;
				if (n + 1 == 100) {
					endIndexs[n] = fc.size();
					break;
				}
				//开始位置
				checkIndex += tempBlockSize;
				//计算出完整的结束位置
				long gapToEof = getGapToEof(checkIndex,randomAccessFile, '\n');
	 
				//结束位置
				checkIndex += gapToEof;
				endIndexs[n] = checkIndex;
			}
			
			boolean findFlag = false;
			for (int i = 0; i < 100; i++) {
				mbb = fc.map(FileChannel.MapMode.READ_ONLY, beginIndexs[i], endIndexs[i]-beginIndexs[i]);
				
				byte[][] lineByte = null;
				while((lineByte = readLine(mbb,beginIndexs[i],endIndexs[i]-beginIndexs[i])) != null){
						if(Arrays.equals(userId.getBytes(),lineByte[0])){
							score = rightTrim(new String(lineByte[1],"GBK"));
							findFlag = true;
							break;
						}
					}
					if(findFlag){
						break;
					}
				}
			} catch (Exception e) {
				e.printStackTrace();
			} finally {
				try {
					randomAccessFile.close();
					fc.close();
					fis.close();
					
				} catch (Exception e2) {
					e2.printStackTrace();
				}
			}
			long endTime=System.currentTimeMillis();
			System.out.println("耗时："+(endTime-starTime));
			System.out.println("用户："+userId+",分数："+score);
			return score;
		}
		
		public static long getGapToEof(long beginIndex,RandomAccessFile randomAccessFile, char separator) {
			long count = 0;
			try {
				randomAccessFile.seek(beginIndex);
				//遇到分隔符结束
				while (randomAccessFile.read() != separator) {
					count++;
				}
				count++;
			} catch (Exception e) {
				e.printStackTrace();
			}
			return count;
		}
		
		/**
		 * 读取每一行的内容
		 * @param mbb
		 * @param begin
		 * @param length
		 * @return
		 */
		public static byte[][] readLine(MappedByteBuffer mbb,long begin,long length) {
			//当前缓冲区总长度
			int limit = mbb.limit();
			//当前位置
			int position = mbb.position();
			//用户ID
			ByteBuffer bb = ByteBuffer.allocate(36);
			//用户分数
			ByteBuffer cc = ByteBuffer.allocate(7);
			try{
				//读取完直接跳出
				if(position >= limit){
					return null;
				}
				//读取到逗号标识
				boolean f = false;
				while(position < limit){
					byte b = mbb.get();
					//每行当读取到逗号时将后面的部分装进用户分数byte数组
					if(b==44){
						f = true;
					}
					//碰到换行符结束读取
					if(System.getProperty("line.separator").equals("\r\n") && (b==13 || b==10)){
						 mbb.get();
						 break;
					}else if(f){
						cc.put(b);
					}else{
						bb.put(b);
					}
				}
			}catch(Exception e){
				e.printStackTrace();
				return null;
			}
			return new byte[][]{bb.array(),cc.array()};
		}
		
		private static String rightTrim(String s){
			char[] cs = s.toCharArray();
			int pos= 0;
			for(int i=cs.length-1;i>=0;i--){
				String tostr = String.valueOf(cs[i]);
				if(tostr.trim().length()!=0){
					pos = i;
					break ;
				}
			}
			return s.substring(0,pos+1);
		}
		
		public static void main(String[] args){
			//源文件路径
			String inputFilePath = "E:/JavaTestFile/user_score.csv";
			//取用户名次
			getUserRank("973e3d81-494f-43b9-a277-10f758297041",inputFilePath);
			
		} 
}
